# 2장 변수 스코프
자바스크립트의 핵심 스코프 규칙이 간단하고, 잘 설계되었으며 믿을 수 없을만큼 강력하다.<br>
하지만 예외가 존재하기 때문에 그에 대한 개념을 익히고 특수한 상황에 대해 숙달해야 한다.<br>
<br>

## 아이템8) 전역 객체의 사용을 최소화하라
전역변수를 정의하는 것은 모든 사람과 공유하는 공통의 네임스페이스를 더럽히고 뜻하지 않게 이름이 충돌할 만한 가능성을 만든다. 실제로 전역 네임스페이스는 자바스크립트 프로그램의 구분된 요소들이 상호작용할 수 있는 유일한 방법이기 때문에 전역 변수의 사용은 불가피하다. 라이브러리나 컴포넌트는 프로그램의 다른 부분에서 사용할 수 있도록 전역 변수 이름을 정의해야 한다.

전역 객체의 사용을 제한하는 게 최선이지만, 한 가지 특별한 필수적인 사용법이 있다. 전역 객체는 전역 환경을 동적으로 반영하기 때문에, 해당 플랫폼에서 사용 가능한 기능을 탐지하지 위해서 실행 환경에 대한 질의를 하는 데 사용할 수 있다. 예를 들어, ES5는 JSON 데이터 형식을 읽고 쓰기 위한 새로운 전역 JSON 객체를 제공한다. 그래서 다음과 같이 JSON 객체에 대한 존재 여부를 확인하고, 있다면 객체를 제공하고 그렇지 않다면 객체를 대체하여 사용할 수 있는 구현체를 제공할 수 있다.
```javascript
if(!this.JSON){
    this.JSON = {
        parse: ...,
        stringify: ...
    };
}
```
<br>

## 아이템9) 항상 지역 변수를 선언하라
전역 변수보다 문제를 일으킬 만한 한 가지가 더 있다면, 그것은 아마 의도하지 않은 전역 변수일 것이다.
```javascript
function swap(a, i, j){
    temp = a[i]; // 전역 변수
    a[i] = a[j];
    a[j] = temp;
}
```
위의 선언으로 인해 temp 변수는 전역 변수가 되었다. 이렇게 의도치 않게 전역 변수를 만드는 것은 완전한 재앙이다. 이 때문에 많은 프로그래머들은 lint 도구를 사용한다. lint 도구는 나쁜 스타일이나 버그를 낼 가능성이 있는 코드를 조사하고, 바인딩되지 않은 변수의 사용에 대해 알리기도 한다. 우연한 전역 변수 선언과 같은 흔한 오류를 확인하는 과정을 개발 프로세스에 통합하여 자동화하면 큰 도움이 될 것이다.<br>
<br>

## 아이템16) eval을 이용해 지역 변수를 생성하지 마라
<img src='./이미지/2장-아이템16-1.png' width="600px"></img><br>

Mdn 문서에서는 eval 함수에 대해서 위와 같은 경고를 하고 있다. eval 함수는 문자로 표현된 자바스크립트 코드를 실행하는 함수이다. eval은 자신의 인자를 자바스크립트 프로그램처럼 해석하지만, 이 프로그램은 호출자의 지역 스코프 안에서 실행된다. 임베드된 프로그램의 전역 변수는 호출한 프로그램의 지역 변수로 생성된다.
```javascript
function test(x) {
    eval("var y = x;");
    return y;
}
test("hello");
```
이때 eval 함수에 임베드된 선언문은 eval 함수가 호출될 때에만 선언된다. 실행되었을 경우, 그 변수를 스코프 내로 가져오게 된다.
```javascript
var y = "global";
function test(src){
    eval(src);
    return y;
}
test("var y = 'local';");   // local
test("var z = 'local';");   // global
```
이 코드는 불안정하고 안정하지 않다. 외부의 호출자가 test 함수 내부 스코프를 변경할 수 있기 때문이다. 이러한 방식은 ES5 스트릭트 모드의 호환성에 적합하지 않으므로 사용되지 않아야 한다. eval이 외부 스코프에 영향을 주지 않도록 하는 간단한 방법은 명시적으로 감싸진 스코프 안에서 실행되도록 하는 것이다.
```javascript
var y = "global";
function test(src){
    (function(){eval(src);})();
    return y;
}
test("var y = 'local';");   // global
test("var z = 'local';");   // global
```
<br>

## 아이템17) 직접적인 eval보다 간접적인 eval을 사용하라
eval 함수는 숨겨진 무기를 가지고 있다. eval 함수는 단순한 함수 그 이상이다. eval 함수는 자신이 호출된 시점의 전체 스코프에 접근할 수 있다. 하지만 이로 인해 모든 함수 호출이 런타임시 eval로 호출되었다고 판명되는 경우, 자신의 스코프를 사용 가능하도록 만들어줘야 하는 상황때문에 최적화 문제에 어려움이 생겨 다음과 같은 절충안은 마련하였다.

표준안에서는 eval을 실행하는 방법을 둘로 나누었다. 식별자 eval을 포함하는 함수 호출은 다음과 같이 직접적인 eval 호출로 간주된다.
```javascript
var x = "global";
function test() {
    var x = "local";
    return eval("x");   // 직접적인 호출
}
test(); // "local"
```
이 경우 컴파일러는 반드시 프로그램이 호출자의 지역 스코프에서 접근을 끝마치게 해야 한다.<br>

다른 방식으로 호출하면 간접적인 호출로 간주하고, 그 인자를 전역 스코프에서 평가한다.
```javascript
var x = "global";
function test(){
    var x = "local";
    var f = eval;
    return f("x");  // 간접적인 호출
}
test(); // "global"
```
직접적인 eval 호출을 만들어 낼 수 있는 유일한 방법은 eval이라는 이름을 가진 변수로 호출하는 것이다.<br>
간접적인 eval 호출을 작성하기 위한 정확한 방법은 다음과 같이 소수점이 없는 숫자 리터럴과 표현식 연속 연산자(,) 뒤에 eval을 두는 것이다.<br>
```javascript
(0, eval)(src);
```
이것의 동작방식은 일반적인 eval 식별자와 거의 똑같이 동작한다. 전체적인 호출 표현식이 간접적인 eval로 처리되는 유일한 차이점을 제외하고 말이다.<br>

직접적인 eval은 이를 포함한 함수와 프로그램의 가장 바깥에 위치한 함수까지 모든 함수를 상당히 느리게 만든다고 가정해야 한다. 경우에 따라 직접적인 eval을 사용해야 할 수도 있으나, 지역 스코프를 조사해야 하는 추가적인 능력이 확실히 필요한 경우에만 사용하고 그렇지 않다면 비교적 오용되기 어렵고 비용이 적게 드는 간접적인 eval을 사용하는 것이 좋다.<br>
<br>