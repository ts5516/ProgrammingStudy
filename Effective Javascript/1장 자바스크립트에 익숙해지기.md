# 1장 자바스크립트에 익숙해지기
자바스크립트는 개발자가 친근하게 느끼도록 설계되었다. 자바스크립트는 다가가기는 쉽지만, 마스터하기까지는 많은 시간이 필요하다.<br>
<br>

## 아이템2) 자바스크립트의 부동 소수점 숫자 이해하기
자바스크립트는 숫자형 데이터가 단 하나밖에 없다.<br>
```javascript
typeof 17; // 'number'
typeof 98.6; // 'number'
typeof -2.1; // 'number'
```
자바스크립트 내의 모든 숫자는 64비트로 인코딩된 부동 소수점(흔히 double, 실수형이라 불림)이다. 때문에 double은 53비트까지의 정확도로 integer(정수형)를 완벽하게 표현할 수 있다. 대부분의 산술 연산자는 정수형과 실수형의 조합으로 동작한다.<br>

반면, 비트단위 연산자는 인자들을 부동 소수점 숫자처럼 처리하지 않고 암묵적으로 32비트 정수로 변환한다. (정확히는 32비트, big-endian, 2의 보수로 처리된다.) 모든 비트단위 연산자는 입력 값을 정수형으로 변환하고, 정수 비트 패턴에서 각 연산을 수행하고 나서, 표준 자바스크립트 부동 소수점 숫자 값으로 변환해 결과를 되돌려준다.<br>

부동 소수점 숫자는 골치아픈 존재이다. 부정확한 결과를 도출하기로 악명높기 때문이다.
```javascript
0.1 + 0.2 // 0.3000000000000000004
```
64비트의 정확도는 충분히 넓지만, double은 실수에 비해 여전히 유한한 숫자 범위만 표현할 수 있다. 그렇기 때문에 부동 소수점 산술 연산은 근사 값을 만들어 가장 가까운 표현가능한 실수로 반올림 한다. 부동 소수점의 정확도와 성능은 상충관계이다. 한가지 유용한 대안은 반드시 정수형태로 변환하여 계산하는 방법이다.
```javascript
//dollar
(0.1 + 0.2) + 0.3; // 0.600000000000000001
0.1 + (0.2 + 0.3); // 0.6

//cent
(10 + 20) + 30; // 60
10 + (20 + 30); // 60
```
<br>

## 아이템3) 암묵적인 형변환에 주의하라
자바스크립트는 데이터형 오류에 놀라울 정도로 관대하다.<br>
```javascript
3 + true; // 당연하다는 듯이 4를 반환한다.
```
자바스크립트에서 잘못된 데이터형으로 인한 오류를 즉시 보여주는 몇가지가 경우가 있는데 다음과 같다.<br>
```javascript
"hello"(1); // 오류: 함수가 아님
null.x; // 오류: null에서 프로퍼티 'x'를 읽어올 수 없음
```
하지만 대부분의 경우 다양한 자동 형변환 프로토콜에 따라 예상되는 데이터형으로 값을 변환시켜준다. 예를 들어, 산술 연산자는 계산전에 인자들을 숫자형으로 변환한다. 특이하게 + 연산자의 경우 숫자의 덧셈이나 문자의 병합이 인자들의 데이터형에 따라 오버로딩한다.
```javascript
2 + 3; //5
'hello' + 'world'; // 'hello world'
```
숫자와 문자열을 합치는 경우, 자바스크립트는 문자열을 우선하여 숫자를 문자로 바꾼다. 이러한 방식은 좌측결합성과 합쳐져 약간의 혼란을 야기한다.
```javascript
'2' + 3; // '23'
2 + '3'; // '23'
1 + 2 + '3'; // '33'
```
비트 연산자의 경우, 32비트 정수로 표현되게 변환되어 값을 계산해준다. 
```javascript
'17' * 3 // 51
'8' | '1' // 9
```
이러한 형변환이 편리하기는 하지만 오류를 숨기게 될 수도 있다. null로 판단된 변수가 자동으로 0으로 변환되거나, 정의되지 않은 변수가 특별한 값인 NaN(IEEE 부동 소수점 표준에 따른 역설적인 이름인 not a number)으로 변환될 수 있다. 이러한 형변환은 즉시 예외를 발생시키지 않고, 예측하기 어려운 값들을 만들어낸다.<br>

NaN의 예시
- 0/0
- 'asdf' * 1000
- Math.sqrt(-9): 허수는 자바스크립트에서 표현불가하다.

NaN이 아닌 예시
- 10/0: Infinity(부동 소수점 숫자의 한계를 넘어가는 숫자)
- -10/0: -Infinity

NaN 값은 테스트하기 어렵다.
- 자바스크립트는 IEEE 부동 소수점 표준에 정의된 이상한 요구사항에 따라 NaN 자신을 동등하지 않다고 처리하기 때문이다.
- 표준 isNaN 라이브러리 함수는 스스로 암묵적인 형변환을 하기 때문에 신뢰할 만하지 않다. (그럼 왜 있는거지??)

하지만 NaN은 자바스크립트에서 자기 자신과 동일하지 않는 유일한 값이기 때문에 이를 활용하여 테스트할 수 있다.<br>
```javascript
var a = NaN;
a !== a; // true
var b = undefined;
b !== b; // false
```
강제 형변환은 객체도 마찬가지로 원시 데이터로 변환시킨다. 암묵적으로 toString 메서드를 사용한다. 또한 명시적으로 valueOf나 toString 메서드를 정의하여 값을 제어할 수 있다.<br>

+연산자는 는 문자 병합과 덧셈에 모두 오버로딩되어 사용된다. 객체가 toString과 valueOf 메서드 둘다를 포함할 경우에 +가 어떤 메서드를 호출하게 될지 명백하지 않다. 자바스크립트는 보이지 않게 valueOf 메서드를 실행한 후 toString을 실행한다. 이러함에도 불구하고 예기치 않은 동작을 불러올 수 있다.
```javascript
var obj = {
    toString: function() {
        return '[object MyObject]';
    },
    valueOf: function(){
        retrun 17;
    }
}
'Object: ' + obj // 'Object: 17'
```
객체가 진짜로 숫자형 추상이 아니고 obj.toString이 obj.valueOf의 문자열 표현을 나타내지 않는다면, valueOf의 사용을 피하는 것이 좋다.<br>

강제 형변환의 마지막 종류는 종종 트루시니스라고 알려져 있다.<br>
자바스크립트는 false, 0, -0, "", NaN, null, undefine을 제외한 값들은 전부 true로 처리한다. 아래 코드는 0을 포함해서 false로 처리되는 어떤 값도 무시한다.
```javascript
function point(x, y){
    if(!x){
        x = 320;
    }
    if(!y){
        y = 240;
    }
    return {x: x, y: y};
}
point(0, 0); // {x: 320, y: 240}
```
undefined를 처리하는 방법은 typeof를 사용하거나 직접비교하는 것이다.
```javascript
function point1(x, y){
    if(typeof x === 'undefined'){
        x = 320;
    }
    if(typeof y === 'undefined'){
        y = 240;
    }
    return {x: x, y: y};
}

function point2(x, y){
    if(x === undefined){
        x = 320;
    }
    if(y === undefined){
        y = 240;
    }
    return {x: x, y: y};
}
```
<br>