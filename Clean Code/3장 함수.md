# 3장 함수
함수에 어떤 속성을 부여해야 처음 읽는 사람이 프로그램 내부를 직관적으로 파악할 수 있을까?
<br><br>

## 1) 작게 만들어라!
함수를 만드는 첫번째 규칙은 작게이다. 두번째 규칙은 더 작게이다.<br>
함수길이 20줄도 길다. 더 짧아야 한다. 다음 코드 정도로 짧으면 좋다.<br>
```java
public static String renderPageWithSetupAndTeardowns
(PageData pageData, boole isSuite) throws Exception{
    if(isTestPage(pageData))
        includeSetupAndTeardownPages(pageData, isSuite);
    return pageData.getHtml();
}
```

- ### 블록과 들여쓰기
    if문/else문/while문 등에 들어가는 블록은 한줄이어야 한다.<br>
    함수 들여쓰기 수준은 1단이나 2단을 넘어서면 안된다.<br>
<br>

## 2) 한 가지만 해라!
> 추상화(abstraction): 복잡한 자료, 모듈, 시스템 등으로부터 핵심적인 개념 또는 기능을 간추려 내는 것

여기서 말하는 한가지란 무엇일까? 그것은 추상화 수준을 의미한다.<br>
위의 코드를 기준으로 설명하자면 다음과 같다.<br>
페이지가 테스트 페이지인지 확인한 후 테스트 페이지라면 설정 페이지와 해제 페이지를 넣는다.<br>
테스트 페이지든 아니든 페이지를 HTML로 렌더링한다.<br>
또 다른 판단 방법은 그 함수가 다른 함수들로 쪼개질 수 있는 여부를 보는 것이다.<br>
<br>

## 3) 함수 당 추상화 수준은 하나로!
> 추상화 수준: 해당 코드를 읽으면서 파악할 수 있는 정보의 수준

```java
//높은 추상화 수준
public void mainButtonAction() throws IOException  {
	if(!isEmptyUserName()) doJoinProcess(duplicateCheck());
	else setUserNameCheck("닉네임이 공백입니다.");	
}

//중간 추상화 수준
String pagePathName = PathParser.render(pagepath);

//낮은 추상화 수준
private String getLocalhost() {
	return "localhost:"+ (5500 + (int)(Math.random()*100));
}
```

- ### 위에서 아래로 코드 읽기: __내려가기__ 규칙
    코드는 위에서 아래로 이야기처럼 읽혀야 좋다. 한 함수 다음에는 추상화 수준이<br>
    한 단계 낮은 함수가 와야한다. 다르게 말하면 일련의 TO 문단을 읽듯이 프로그램이 읽혀야 한다.<br>
    여기서 TO 문단은 현재 추상화 수준을 설명하며 이어지는 아래 단계 TO 문단을 참고한다.<br>
<br>

## 4) Switch 문
> 다형성(polymorphism): 하나의 객체가 여러 가지 타입을 가질 수 있는 것<br>
> SRP(Single Responsibility Principle): 클래스를 변경하는 이유는 단 한가지여야 한다.<br>
> OCP(Open Closed Principle): 기존의 코드를 변경하지 않으면서 기능을 추가할 수 있도록 설계되어야 한다.<br>

switch 문은 본질적으로 N가지 작업을 처리하도록 만들어졌기 때문에 작게 만들기 어렵다.<br>
하지만 각 switch 문을 저차원 클래스에 숨기고 절대로 반복하지 않는 방법은 있다. 다형성을 이용한다.<br>

```java
public Money calculatePay(Employee e)
        throws InvalidEmplᄋyeeType {
    switch (e.type) {
        case COMMISSIONED:
            return caleulateCommissionedPay(e);
        case HOURLY:
            return calculateHourlyPay(e);
        case SALARIED:
            return calculateSalariedPay(e);
        default:
            throw new InvalidEmployeeType(e.type);
    }
}
```
위의 코드의 문제는 다음과 같다.<br>
1. 함수가 너무 길다.
2. '한 가지' 작업만 수행하지 않는다.
3. SRP를 위반한다.
4. OCP를 위반한다.
5. (가장 심각한 문제)위 함수와 구조가 동일한 함수가 무한정 존재한다.

아래 코드를 보자
```java
public abstract class Employee {
    public abstract boolean isPayday();
    public abstract Money calculatePay();
    public abstract void deliverPay(Money pay);
}

public interface EmployeeFactory {
    public Employee makeEmployee(EmployeeRecord r) throws InvalidEmployeeType;
}

public class EmployeeFactorylmpl implements EmployeeFactory {
    public Employee makeEmployee(EmployeeReco rd r) throws InvalidEmployeeType {
        switch (r.type) {
            case COMMISSIONED:
                return new CommissionedEmployee(r);
            case HOURLY:
                return new HourlyEmployee(r);
            case SALARIED:
                ret니rn new SalariedEmployee(r);
            default:
                throw new InvalidEmployeeType(r.type);
        }
    }
}
```